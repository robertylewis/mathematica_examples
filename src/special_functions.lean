/-
Copyright (c) 2017 Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Robert Y. Lewis
-/

import mathematica
import analysis.calculus.deriv
open tactic

/-!
This demo shows how we can axiomatically accept results from Mathematica.
Bessel functions <https://en.wikipedia.org/wiki/Bessel_function> are not defined in mathlib,
but we can add a constant with the right type,
and import properties from Mathematica as axioms.
-/

open real

/-
`deriv` is the single variable Frechet derivative.
In the case of `ℝ`, it specializes to the familiar derivative.
-/
#check (deriv : (ℝ → ℝ) → (ℝ → ℝ))

/-
We add a constant representing Bessel functions and an axiom with their defining property.
-/
constant BesselJ (n : ℝ) (z : ℝ) : ℝ

axiom BesselJ_def (n : ℝ) (z : ℝ) :
  z*z*(deriv (deriv (BesselJ n)) z) + z*(deriv (BesselJ n) z) + (z*z-n*n)*(BesselJ n z) = 0

section
open mathematica

/-
We translate Mathematica's Bessel functions to our new type.
-/
@[sym_to_pexpr]
meta def BesselJ_trans : sym_trans_pexpr_rule :=
⟨"BesselJ", ``(BesselJ)⟩

end

/--
`make_bessel_fn_eq` takes an expression,
simplifies it in Mathematica,
translates it back to Lean,
and axiomatizes the equality of the input and output.

Note that this has nothing specific to do with Bessel functions besides the translation rules used.
-/
meta def make_bessel_fn_eq (e : expr) : tactic (expr × expr) :=
do pe ← mathematica.run_command_on_using
     (λ t, t ++ "// LeanForm // Activate // FullSimplify") e "bessel.m",
   val ← to_expr ``(%%pe : ℝ),
   tp ← to_expr ``(%%e = %%val),
   nm ← (++) `mathematica_axiom <$> new_aux_decl_name,
   l ← local_context,
   l' ← mfilter (kdepends_on tp) l,
   gls ← get_goals,
   m ← mk_meta_var tp,
   set_goals [m],
   generalizes l',
   tp' ← target,
   set_goals gls,
   let dcl := declaration.ax nm [] tp',
   add_decl dcl,
   prf ← mk_const nm,
   return (val, prf)

/--
`approx e q` axiomatizes a numeric approximation of `e` to precision `q`,
where `e` and `q` have type `ℝ`.
-/
meta def approx (e q : expr) : tactic (expr × expr) :=
do pe ← mathematica.run_command_on_2
     (λ e q, "Rationalize[" ++ e ++ " // LeanForm // Activate // N, " ++ q ++ "// LeanForm // Activate]")
     e q,
   val ← to_expr ```(%%pe : ℝ),
   (lb, _) ← to_expr ```(%%val - %%q) >>= norm_num.derive,
   (ub, _) ← to_expr ```(%%val + %%q) >>= norm_num.derive,
   tgt ← to_expr ```(%%lb < %%e ∧ %%e < %%ub),
   nm ← new_aux_decl_name,
   let nm' := `approx_axiom ++ nm,
   let dcl := declaration.ax nm' [] tgt,
   add_decl dcl,
   prf ← mk_const nm',
   return (val, prf)

namespace tactic
namespace interactive

setup_tactic_parser

meta def simplify_target : itactic :=
do (t, _) ← target >>= match_eq,
   (_, prf) ← make_bessel_fn_eq t,
   tactic.apply prf $> ()

meta def approx (e : parse parser.pexpr) (q : parse parser.pexpr) : itactic :=
do e' ← i_to_expr e,
   q' ← i_to_expr q,
   (_, prf) ← _root_.approx e' q',
   n ← get_unused_name `approx none,
   tactic.note n none prf, skip

end interactive
end tactic












variable x : ℝ

/-
This example proves an equality between Bessel functions
by checking in Mathematica that the left hand side simplifies to the right hand side.

Below we can see the axiom generated by Mathematica.
-/
def f1 : x*BesselJ 2 x + x*BesselJ 0 x = 2*BesselJ 1 x :=
by simplify_target

/-
In this example we axiomatically add an approximation to a numeric value to the context.
Below we look at all axioms currently in the environment.
Because this approximation was not actually used in the proof,
it doesn't appear in the list of axioms.
-/

theorem apr : true :=
begin
  approx (100*BesselJ 2 0.52) (0.00001 : ℝ),
  trace_state,
  triv
end

#print axioms
